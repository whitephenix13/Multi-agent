to update_addbus_intention
  ; initialize 6 bus with different routes at the beginning
  ifelse ticks = 2 [
    set addbus_intention "addinit"
  ]
  [
    set addbus_intention "none"
  ]
  ;other add option is in apply reply
end 

to update_desire
end 
to update_drive_intention
  if (drive_intention = "deviate")
  [
    ;we reached the end of the deviation 
    if(route_index = length(deviate_route) )
    [
      ;current_stop
      if(current_stop = -1 ) 
      [show (word "WARNING: current stop is -1 although it should be " length(deviate_route))]
      
      
      ;update bus_deserving_stations
      ;the bus was in deviate and its previous route has already been removed from the variable
      set bus_deserving_stations (update-bus-deserving-stations bus_deserving_stations bus_id new_fixed_route)
      
      set fixed_route new_fixed_route
      set route_index position (item (length(deviate_route) - 1 ) deviate_route) new_fixed_route
      set direction "GO"
      set drive_intention "deserve"  
    ]
  ]
end 

;take the list of all recent messages as input 
to update_comm_intention [f_messages]
  let d_tick (ticks - disable_tick)
  let break? false ; used to simulate an if elseif elseif else behaviour 
  
  if (comm_intention = "disable" and (not break?))
  [
    if( d_tick > 15) ;1 ticks per minutes, 1440 let's say that the delay is of 15 min (since rush hours last ~2 hours)
    [
      set comm_intention "none"
    ]  
    set break? true
  ]
  if( comm_intention = "send" and (not break?))
  [
    set comm_intention "disable"
    set break? true
  ]
  ;TODO: ALex LELL
  ;TODO: compute the current_route using the same type of code as below
  ;TODO if current_route != -1
     ;TODO check if the bus is at a station he deserves (see check_stations? below) and that he is not replying to a message ( (ticks - last_reply_time) > 2, ie I did not send a reply 
     ;during update-message-intentions
        ;TODO: check for undercrowded station using the function in heuristic
        ;TODO: if station_id != -1 ; ie: find one 
               
               ;TODO calculate current heuristic (see apply request) 
               
               ;TODO: calculate new route (use best-drop-station)
               ;TODO: calculate new drive_intention (see apply request)
               ;TODO: use the above to calculate new heuristic 
               
               ;TODO: calculate delta heuristic 
               
               ;TODO: if delta heuristic > 0
                   ;TODO: set station_to_drop
                   ;TODO: set station_to_drop_heur
               
                   ;TODO: build message_content using build-INFORM-content task_name (list var1 var2 ... varn) where var are station_id and delta_heuristic (or more if necessary)
                   ;TODO: let message_id (build-m-id bus_id)
                   ;TODO: build message build-message bus_id message_id "INFORM" message_content
                   ;TODO: find all buses that deserve this station using bus_deserving_stations
                   ;TODO: send a the message using  my-send-message bus_id_to_send message for all buses to whom you have to send
      
                   ;TODO set break? true
  
  if (add_bus_index != -1)
  [
    ; send an init message to the bus
    let content (build-INFORM-content "init" (list add_fixed_route add_deviate_route add_start_delay add_direction add_route_index add_desire add_drive_intention add_comm_intention add_addbus_intention))
    let message_id (build-m-id bus_id)
    let message (build-message bus_id message_id "INFORM" content)
    my-send-message add_bus_index message
  ]
  if( comm_intention = "none" and (not break?))
  [
    let current_route -1
    if(drive_intention = "deserve" )
    [set current_route fixed_route]
    ;we do not check for optimization if we are deviating 
    if(drive_intention = "deviate" )
    [set current_route -1]
    
    if current_route != -1
    [
      let break2? false
      ;only check station if we are at the current station
      let check_stations? (member? current_stop current_route) 
      ;only check line if we are at the first of last station of main_route (=fixed_route)
      let check_line? ( (current_stop = (first current_route) ) or (current_stop = (last current_route)) )
      
      
      if(check_line? and (break2? = false))
      [
        let overcrowded_line? (check-overcrowded-line current_route)
        let delay_fine? false 
        if (overcrowded_line? != false)
        [
          set delay_fine?  (line_delay_ok overcrowded_line overcrowded_line? ticks)
        ]
        
        if(delay_fine? = true and (not break2?))
        [     
          set message_receivers (list)
          set message_to_send "" 
          
          ;Send message to every bus does not already have all of my stop in his line
          foreach bus_id_list [
            let bus_route -1
            ask buses with[bus_id = ?] [set bus_route fixed_route]
            if( (equal-route-stops current_route bus_route) = false)
            [
              set message_receivers lput ? message_receivers
            ]
          ]
          let treshold 0 ; if the delta heuristic of the bus is >0 then the bus can respond to the request
          let message_cont (build-REQUEST-content "overcrowded_line" current_route treshold)
          let mess_id (build-m-id bus_id)
          set message_to_send (build-message bus_id mess_id "REQUEST" message_cont)
          set last_sent_request message_to_send
          
          show word (word (word (word "send request" "") message_to_send) " " ) ticks
          
          ;memorize that a request was sent for this line 
          ;first: clean var
          set overcrowded_line (clean_delay_var overcrowded_line ticks)
          ;then add this line to the list 
          set overcrowded_line lput (list current_route ticks) overcrowded_line
          set break2? true
        ]
      ]
      if(check_stations? and (break2? = false))
      [
        let overcrowded_station? (check-overcrowded-station current_stop)
        let delay_fine? false 
        if (overcrowded_station? != false)
        [
          set delay_fine?  (station_delay_ok overcrowded_station overcrowded_station? ticks)
        ]
        if (delay_fine? = true and (not break2?))
        [
          
          set message_receivers (list)
          set message_to_send "" 
          
          ;send message to buses that don't have this stop in their route
          foreach bus_id_list [
            let bus_route -1
            ask buses with[bus_id = ?] [set bus_route fixed_route]
            if(not ( member? current_stop bus_route) )
            [
              set message_receivers lput ? message_receivers
            ]
          ]
          let treshold 0 ; if the delta heuristic of the bus is >0 then the bus can respond to the request
          let message_cont (build-REQUEST-content "overcrowded_station" current_stop treshold)
          let mess_id (build-m-id bus_id)
          set message_to_send (build-message bus_id mess_id "REQUEST" message_cont)
          set last_sent_request message_to_send
          
          show word (word (word (word "send request" "") message_to_send) " " ) ticks
          
          ;memorize that a request was sent for this station 
          ;first: clean var
          set overcrowded_station (clean_delay_var overcrowded_station ticks)
          ;then add this line to the list 
          set overcrowded_station lput (list current_stop ticks) overcrowded_station
          set break2? true
        ]
      ]
      
      
      ;if we entered in one of the previous if, change behaviour to send and set disable_ticks
      if( break2? = true) 
      [
        set comm_intention "send"
        set disable_tick ticks
      ]
      set break? true
    ]
  ]
  
end 

;Update all the bus intention depending of the message 
to update-message-intentions [f_messages]
  let all_filtered (filter-message f_messages)
  let m_inform (item 0 all_filtered)
  let m_request (item 1 all_filtered)
  let m_reply (item 2 all_filtered)
  let m_action (item 3 all_filtered) 
  
  applyInform m_inform
  
  applyRequest m_request
  
  applyReply m_reply f_messages
  
  
  foreach m_action
  [
    let content get-content ?
    let info (read-ACTION-content content)
    applyAction (item 0 info) (item 1 info)
  ]
  
end
;TODO: check if not probelm with action message 
to applyInform[m_inform]
  ;TODO: Alex LELL 
  ;TODO: create list to memorize the delta heuristic for drop
  ;TODO: create list (same order as previous one! ) to memorize the bus_id for drop
  
  foreach m_inform
  [ 
    ;parse message and get a list where the first element is the task name, all the following one are the var values AS A STRING ; (use "read-from-string str" to get an integer/list ... of the list 
    let list_infos (read-INFORM-content ?)
    let task_name (item 0 list_infos)
    if task_name = "init"
    [
      set fixed_route add_fixed_route
      set deviate_route add_deviate_route
      set start_delay add_start_delay
      set direction add_direction
      set route_index add_route_index
      set desire add_desire
      set drive_intention add_drive_intention
      set comm_intention add_comm_intention
      set addbus_intention add_addbus_intention
      
      if(drive_intention = "deserve")
      [set bus_deserving_stations (update-bus-deserving-stations bus_deserving_stations bus_id fixed_route)]
    ] 
      ;TODO: check if task_name is nameOfTheTaskForDrop 
          ;TODO: check if station_id of the message is the same as station_to_drop
              ;TODO add bus id to list of bus_id_drop 
              ;TODO add d_heuristic to list of d_heur_drop 
  ]
  ;TODO if at least one bus does not want to drop the station I want to drop (check length of drop_list +1 (!!!! +1 to count myself) and bus_deserving_stations)
      ;TODO: compute new route (think carefully at where the station you are dropping is, you might need to change the route_index and direction values)
      ;TODO: compute new bus_deserving_station
      ;TODO: set station_to_drop to -1
      ;TODO: set station_to_drop_heur to 0 
      ;TODO: drop station 
  ;TODO: else
      ;TODO: add my id to the list (if not done) and my d_heur to the list (if not done) using the one I memorized in station_to_drop_heur
      ;TODO: compute min d_heuristic and corresponding bus_id 
      ;TODO: if I am not the min, I can drop a station: 
         ;TODO: compute new route (think carefully at where the station you are dropping is, you might need to change the route_index and direction values)
         ;TODO: compute new bus_deserving_station
         ;TODO: set station_to_drop to -1
         ;TODO: set station_to_drop_heur to 0 
         ;TODO: drop station 
  

end

to applyRequest[m_request]
  let heuristics_dvalue (list) ; store the gain/loss in heuristic by the change
  let corresponding_mess (list) ; corresponding message to the heuristic_dvalue 
  
  let current_route -1
  if(drive_intention = "deserve" )
  [set current_route fixed_route]

  if(drive_intention = "deviate" )
  [set current_route -1]
    
  if current_route != -1  
  [
    foreach m_request
    [
      let content get-content ?
      let info ( read-REQUEST-content content )
      let var_name (item 0 info)
      let var_val (item 1 info)
      let treshold (item 2 info)
      
      let break? false
      
      if(var_name = "overcrowded_line" and (break? = false))
      [
        ;wait for every bus to be on the line 
        if( ticks > 60) 
        [
          ;compute the cost of reaching the new route
          let next_index (item 1 (get-next-direction-index bus_id))
          let next_s (item next_index current_route)
          let dev_route (find-way-to-route next_s var_val)
          let dev_cos (travel-gain bus_type dev_route)
          
          ;compute the heuristic for deserving the next route 
          let new_bus_deserv (update-bus-deserving-stations bus_deserving_stations bus_id var_val )
          let new_heur (heuristic bus_type var_val ticks new_bus_deserv)
          ;compute current heuristc 
          let cur_heur (heuristic bus_type current_route ticks bus_deserving_stations)
          
          ;compute the difference between heuristic
          let d_heur ( (new_heur + dev_cos) - (cur_heur) )
          
          if( d_heur > treshold)
          [ 
            ;check if we are not alredy on the new route
            if (current_stop = (first dev_route))
            [
              set dev_route (remove-item 0 dev_route)
            ]
            ifelse(length(dev_route) = 0)
            [
              set new_drive_intention "deserve"
              set deviate_route []        
            ]
            [
              set new_drive_intention "deviate"
              set deviate_route dev_route
            ]
            
            set new_fixed_route var_val
            set heuristics_dvalue lput d_heur heuristics_dvalue
            set corresponding_mess lput ? corresponding_mess
        
          ]
          
          ;memorize that a request was sent for this line 
          ;first: clean var
          set overcrowded_line (clean_delay_var overcrowded_line ticks)
          ;then add this line to the list 
          set overcrowded_line lput (list var_val ticks) overcrowded_line
        ]
        set break? true
      ]
      if(var_name = "overcrowded_station" and (break? = false) )
      [
        ;wait for every bus to be on the line 
        if( ticks > 60) 
        [
          ;compute route induced by the addition of the overcrowded station to current_route
          let new_route (best-route var_val current_route)
          ;compute new and previous gain
          let new_bus_deserv (update-bus-deserving-stations bus_deserving_stations bus_id new_route )
          let new_heur  (heuristic bus_type new_route ticks new_bus_deserv)
          let cur_heur (heuristic bus_type current_route ticks bus_deserving_stations) 
          let d_heur (new_heur - cur_heur)
          if( d_heur > treshold)
          [
            set new_drive_intention "deserve"
            set deviate_route []
            set new_fixed_route new_route
            set heuristics_dvalue lput d_heur heuristics_dvalue
            set corresponding_mess lput ? corresponding_mess
          ]
          
          ;memorize that a request was sent for this station 
          ;first: clean var
          set overcrowded_station (clean_delay_var overcrowded_station ticks)
          ;then add this line to the list 
          set overcrowded_station lput (list var_val ticks) overcrowded_station
        ]
        set break? true
      ]
      
      if(break? = false)
      [
        show( word (word "WARNING: the following variable name: " var_name) " was not handled in applyRequest")
      ]
    ]
    if(length(heuristics_dvalue) > 0)
    [
      ;find best request to answer to 
      let best_dvalue max heuristics_dvalue
      let best_dvalue_index position best_dvalue heuristics_dvalue
      
      ;Send message to bus
      let best_m (item best_dvalue_index corresponding_mess)
      let message_id (get-m-id best_m)
      let best_sender_id  (get-sender best_m)
      let reply_message (build-message bus_id message_id "REPLY" (build-REPLY-content best_dvalue))
      
      ;send the message 
      my-send-message best_sender_id reply_message
      show word (word (word (word "send reply" best_sender_id) reply_message) " " )ticks
      
      ;memorize the tick :
      set last_reply_time ticks
    ]
  ]
end


to applyReply[m_reply f_messages]
  let heuristics_dvalue (list) ; store the gain/loss in heuristic by the change
  
  let gain 0
  if(length (m_reply) = 0 and drive_intention = "deserve")
  [
    set gain gain + (heuristic bus_type fixed_route ticks bus_deserving_stations + bus_cost * 420)
    if(gain > 0)
    [
      set addbus_intention "add"
      set add_size 3
      set add_fixed_route fixed_route
      ifelse member? 3 fixed_route [set add_deviate_route find-way-to-route 3 fixed_route]
      [set add_deviate_route (list)]
      set add_start_delay 0
      ifelse member? 3 fixed_route 
      [
        let ind position 3 fixed_route
        ifelse(ind < length(fixed_route) - 1)
          [
            set add_route_index (ind + 1)
            set add_direction "GO"
          ]
          [
            set add_route_index (ind - 1)
            set add_direction "RETURN"
          ]
      ]
      [
        set add_route_index 0
        set add_direction "GO"
      ]
      set add_desire "deserve"
      ifelse(add_deviate_route != 0)[set add_drive_intention "deviate"]
      [set add_drive_intention "deserve"]
      set add_comm_intention "none"
      set add_addbus_intention "none"
    ]
  ]
  ;if received no reply, check if should add a bus, if that is the case, the bus will only be added at the end of the tick: send a message at next tick to this bus to initialize it
  ;TODO: Rezka
  ;TODO:if length m_reply =0 and drive_intention = "deserve"
     ;TODO estimate needed bus size: estimate number of people to pick during a route loop, use mean_time_between_stop = 6.25/1 (see heuristics) * nb_stop (time for route)
     ; then estimate the number of people expected for the next hour and multiply by expected_route_time/60 (if expected_route_time<60, toherwise consider several hours...)
     ;TODO: estimate bus addition gain = total bus heuristic (calculate from now until the end of the run, ie ticks =1440) + bus init cost *mean_time(=420)
     ;TODO: if addition gain > 0 
        ;TODO: set addbus_intention "add"
        ;TODO: set good parameter for creation:
        ;TODO: set add_size ;1 or 2 or 3
        ;TODO: set add_fixed_route fixed_route ; same route as mine
        ;TODO: set add_deviate_route ; if member? 3 fixed_route (if centraal is a member of the fixed route), set this to find-way-to-route 3 fixed_route, else (list)
        ;TODO: set add_start_delay ; if needed to add a delay. If no idea what to do, set it to 0 
        ;TODO: set add_route_index; if centraal in fixed route: [compute "let ind position 3 fixed_route". if ind <length(fixed_route)- 1, set add_route_index (ind + 1) and set add_direction "GO"
        ; else set add_route_index (ind - 1)  and set add_direction "RETURN" ], else set it to 0 and set add_direction to "GO"
        ;TODO: set add_direction ; see above 
        ;TODO: set add_desire ; mostly "deserve", can also be "connect line"
        ;TODO: set add_drive_intention; if has to deviate (ie: add_deviate_route is not null), set to "deviate" else, set to "deserve"
        ;TODO: set add_comm_intention; set to "none"
        ;TODO: set add_addbus_intention; set to "none"
        
  foreach m_reply
  [
    let content get-content ?
    let dvalue ( read-REPLY-content content )
    set heuristics_dvalue lput dvalue heuristics_dvalue
  ]
  if( (length heuristics_dvalue) > 0 )
  [
    ;find best reply to answer to 
    let best_dvalue max heuristics_dvalue
    let best_dvalue_index position best_dvalue heuristics_dvalue
    
    ;find best reply message and get some infos 
    let best_m (item best_dvalue_index m_reply)
    let message_id (get-m-id best_m)
    let best_sender_id (get-sender best_m)
    
    let original_message last_sent_request 
    let original_content (read-REQUEST-content (get-content original_message))
    let var_name (item 0 original_content)
    let var_value (item 1 original_content)
     
    ;Resend original message to the bus but this time as an action: notify him that he has to do the changes he did for the computation of delta heuristic
    let action_message (build-message bus_id message_id "ACTION" (build-ACTION-content var_name var_value)) 
    my-send-message best_sender_id action_message
    show word (word "send action " best_sender_id) action_message
  ]
end

to applyAction[var_name var_value]
    let break? false
    if(var_name = "overcrowded_station")
    [
      show word word word word "deviate to overcrowded station !!!!!: " (item route_index fixed_route) " " fixed_route " => "
      set drive_intention new_drive_intention
      show word "Current drive intention " drive_intention
      ;deviate route has already been set 
      
      ;update bus_deserving_stations
      ;the bus was will go in deviate: only remove previous route
      set bus_deserving_stations (update-bus-deserving-stations bus_deserving_stations bus_id new_fixed_route)
     
      ;direction stays the same 
      ;set the route index to the correct value
      set route_index (position (item route_index fixed_route) new_fixed_route)
      set fixed_route new_fixed_route
      
     show word word (item route_index new_fixed_route) " " new_fixed_route 
            
      set break? true
    ]
    if(var_name = "overcrowded_line")
    [
      show word word word word "deviate to overcrowded line !!!!!" current_stop " " deviate_route var_value
      set drive_intention new_drive_intention
      ;deviate route has already been set 
      
      ;update bus_deserving_stations
      ;the bus was will go in deviate: only remove previous route
      set bus_deserving_stations (update-bus-deserving-stations bus_deserving_stations bus_id [])
      
      ifelse(length(deviate_route) != 0)
      [
        set route_index 0 ; go to first stop of deviate route
        set direction "GO"
      ]
      [      
        ;keep same values
      ]

      set break? true
    ]
    if(break? = false)
    [
      show( word (word "WARNING: the following variable name: " var_name) " was not handled in applyReply")
    ]

end