buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
    
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.

]
 
globals [graph]

to init-buses
  ; Initialize your agents here.

  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
end

to execute-actions
  ; Add decision making strategies for your agents here.
  ; You are allowed to use the global variable 'ticks'.
  let itermediate []
  let temp (shortest-route 0 itermediate 5)
  show temp

end

to-report shortest-route [start-stop intermediate-stops end-stop]
  let res (list)
  let prev_stop start-stop
  foreach intermediate-stops
  [
    foreach (shortest-route2 prev_stop ?1)
    [
      set res lput ? res  
    ]
    ;remove last elements to avoid duplicates 
    set res (remove-item ((length res) - 1) res )
    set prev_stop ?1
  ]
  foreach (shortest-route2 prev_stop end-stop)
  [
      set res lput ? res  
  ]
  report res
end

to-report shortest-route2 [start-stop end-stop]

  let infinity 10000000000
  let dist (n-values 24 [infinity])
  set dist(replace-item start-stop dist 0)
  
  let prev (n-values 24 [-1])
  
  ;specific representation: elements in queue have value < infinity , with their value equal to their distance
  let queue (n-values 24 [infinity])
  set queue(replace-item start-stop dist 0)
  
  let graph-list (n-values 24 [0])
  let ind 0
  foreach graph-list
  [
    set graph-list(replace-item ind graph-list ind)
    set ind (ind + 1)
  ]
  let stop? False
  ;let temp 0 
  while[ stop? = False]
  [
    ;take shortest distance from queue
    let min-val min queue
    let min-val-index position min-val queue
    ;if shortest is end-stop, exit
    if min-val-index = end-stop [
      set stop? True
      ]
    ;else remove itself from queue and add neighboor to queue 
    set queue (replace-item min-val-index queue (infinity + 1))
    
    ;loop over all neighboors
    foreach (item min-val-index graph)
    [
      let new-dist ((item min-val-index dist) + (get-distance min-val-index ? ))
      
      if  (((new-dist) < (item ? dist)) )[
      set prev(replace-item ? prev min-val-index)
      set dist (replace-item ? dist new-dist)
      set queue (replace-item ? queue (item ? dist))]
    ]

    ;set temp (temp + 1)
    ;if temp = 2 [set stop? True]
  ]
  let res (list)
  let elem end-stop
  set stop? False
  while[ stop? = False]
  [
    set res fput elem res 
    if elem = start-stop
    [set stop? True]
    set elem (item elem prev)
  ]
  ;set res reverse res
  report res
end

