__includes [ "shortest-route.nls" "communicate.nls" "behaviour.nls"]
buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
    
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.
  fixed_route     ; Route that buses will follow 
  counter         ; Counter to keep track of the current index of the fixed_route where the bus is  
  bus_capacity    ; Keep track of maximum possible number of person
  
  ;Behavioural variables 
  desire          ; Can be "deserve" (deserve its line) "maintain" (assure that rarely used station are deserved) "connect" (assure connections between several lines)
  addbus_intention   ; Can be "addinit"(add buses at the beginning) "add" (add bus during runtime) "none"
  drive_intention ; Can be "wait"(do not move) "deserve"(deserve its own line) "pick_extra"(pick passenger from another line) "drop_extra" (drop passenger to another line) "deviate"
  comm_intention  ; Can be "send"(send a message" "wait" (wait for an answer) "disable" (can't send message because it already sent one x ticks ago) "none" (do nothing)
  ;TODO? add belief : “number of people at a station” “most/least deserved station” ... 
]
 
globals [graph bus_number]

to init-buses

  ; Initialize your agents here.
  set counter 0
  if bus_id mod 6 = 0 [set fixed_route [3 9 8 6 8 2 8 9]]
  if bus_id mod 6 = 1 [set fixed_route [3 20 12 15 18 15 12 20]]
  if bus_id mod 6 = 2 [set fixed_route [3 20 21 22 0 22 21 20]]
  if bus_id mod 6 = 3 [set fixed_route [3 4 10 13 23 14 23 13 10 4]]
  if bus_id mod 6 = 4 [set fixed_route [3 4 5 17 7 1 19 1 7 17 5 4]]
  if bus_id mod 6 = 5 [set fixed_route [3 16 11 16]]
  
  if bus_type = 1 [set bus_capacity 12]
  if bus_type = 2 [set bus_capacity 60]
  if bus_type = 3 [set bus_capacity 150]

  set desire "deserve" 
  set drive_intention "deserve" 
  set comm_intention "none"
  set addbus_intention "none"
  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
  
  ;TEST FUNCTIONS 
  ;show (split "[1 2 3]/test/5" "/")
  ;show (shortest-route2 0 5)
  ;let mess-id (build-m-id bus_id) 
  ;let mess (build-message bus_id mess-id "INFORM" "I am happy")
  ;show mess
  ;show (read-message mess)
end

to drop-passenger 
  ; if the bus is in centraal, drop everyone that don't have this destination on this route
  ifelse current_stop = 3 
  [
      foreach bus_passengers 
      [ 
        let pass_stop (item 1 ?)  
        let should_drop? True
        ;check if passenger stop is on the bus route
        foreach fixed_route 
        [
          let route ?
          if (pass_stop = route )
          [ set should_drop? False ]
        ]
        ;check if the passenger stop is the current_stop 
        set should_drop? ((pass_stop = current_stop) or should_drop?)
        if (should_drop? = True)[drop-off-passenger (item 0 ?) ]
      ]
  ]
  [
    ; drop a passenger if it is his stop
      foreach bus_passengers [
        if item 1 ? = current_stop [drop-off-passenger (item 0 ?)] 
      ]
  ]
end
to pick-passenger 
    ; if the bus is in centraal pick passenger with destination that matches the bus route
    ifelse current_stop = 3 
    [
        foreach get-passengers-at-stop (current_stop) 
        [
          if length(bus_passengers) < bus_capacity 
          [
            let v ?
            foreach fixed_route 
            [
              if ((item 1 v = ?) and (? != current_stop) )[ pick-up-passenger (item 0 v) ]
            ]
          ]
        ]
    ]
    [
      ; if its not in centraal, we only pick passenger if we can drop him before going to the same station
      
      ; the checking part, we check if we should pick a passenger
      let check_stop_position counter mod length(fixed_route)
      let indexes n-values length fixed_route [ ? ] 
      ; L is a list of station before going to the same station
      let L []
      ; boolean to stop adding
      let halt false
      foreach indexes [
        let check_index (? + check_stop_position) mod length (fixed_route)
        ; show check_index
        ifelse current_stop != item check_index fixed_route [
          if halt = false [
            set L lput item check_index fixed_route L
          ]
        ]
        [
          set halt true
        ]
      ]
      
      ; if the bus is not full 
      if length(bus_passengers) < bus_capacity 
      [ foreach get-passengers-at-stop (current_stop) 
        [  
          if length(bus_passengers) < bus_capacity 
          [
            ; if the passenger's destination is on this bus route and is on L, pick the passenger
            ifelse member? item 1 ? fixed_route 
            [
              if member? item 1 ? L 
              [
                pick-up-passenger (item 0 ?)
              ]
            ]
            ; if the passenger's destination is not on this bus route, but the bus goes to centraal, pick the passenger
            [
              if member? 3 L 
              [
                pick-up-passenger (item 0 ?)
              ]
            ]
          ]
        ]
      ]
    ]
      
end
to execute-actions
  
  update_desire
  update_addbus_intention
  update_drive_intention
  update_comm_intention
  
  if(addbus_intention = "addinit")
  [
    ; initialize 6 bus with different routes at the beginning
    let i 0
      while [i < 6] [
        if bus_number != 0 [add-bus(3)]
        set bus_number bus_number + 1
        set i i + 1
      ]
  ]
  if(addbus_intention = "add")
  [
    ; add more bus as time increases
    add-bus(3)
    set bus_number bus_number + 1
  ]
  
  ; check whether a bus is in a bus stop
  if current_stop = item (counter mod length(fixed_route)) fixed_route [
    set counter counter + 1
    drop-passenger
    pick-passenger 
  ]
  
  if(drive_intention = "deserve")[
  travel-to item (counter mod length(fixed_route)) fixed_route ]
end

