__includes [ "shortest-route.nls" "communicate.nls" "behaviour.nls" "heuristics.nls"]
buses-own [
  ; Static, read-only variables. These values never change. You can read them, but you cannot change them.
  bus_id          ; The ID of a given agent (bus). Each agent has a unique ID.
  bus_type        ; The type of a given agent (bus). 1 means "small", 2 means "medium" and 3 means "large".
    
  ; Dynamic, read-only variables. These values may change over time. You can read them, but you cannot change them.
  inbox           ; List containing all the incoming messages (a given message is a list like this [tick sender message]).
  bus_passengers  ; List containing all the passengers that the agent (bus) is currently carrying (represented as a list like this [passenger_id bus_stop]).
  previous_stop   ; ID of the last bus stop that the agent (bus) visited (-1 means that the agent has not visited any bus stop yet).
  current_stop    ; ID of the bus stop where the agent (bus) currently is (-1 means that the agent is not at any bus stop).
  next_stop       ; ID of the bus stop the agent (bus) is traveling to (-1 means that the agent is not travelling to any bus stop).

  ; New local variables for students.
  ; You can create any new local variable you want. Just declare them here.
  fixed_route     ; Route that buses will follow 
  direction       ; String: "GO" for normal route (read fixed_route from left to right) or "RETURN" (read table from right to left)
  route_index     ; Counter to keep track of the current index of the fixed_route where the bus is  
  bus_capacity    ; Keep track of maximum possible number of person
  travelled_distance    ; Distance that is travelled by bus 
  
  ;Behavioural variables 
  desire          ; Can be "deserve" (deserve its line) "maintain" (assure that rarely used station are deserved) "connect" (assure connections between several lines)
  addbus_intention; Can be "addinit"(add buses at the beginning) "add" (add bus during runtime) "none"
  drive_intention ; Can be "wait"(do not move) "deserve"(deserve its own line) "pick_extra"(pick passenger from another line) "drop_extra" (drop passenger to another line) "deviate"
  comm_intention  ; Can be "send"(send a message) "disable" (can't send message REQUEST or INFORM) "none" (do nothing)
  message_content         ; Set this variable in behaviour.nls when the bus wants to send a message. This will be the message sent.
  disable_tick    ; tick value when the bus send a message for a discussion he initiated. Prevents spamming 
  
  ;Belief variables
  overcrowded_station; station_id of the overcrowded station that the bus must take care of if he got message agreement from sender
  overcrowded_line   ; route (ie list of bus stop)  that the bus must take care of if he got message agreement from sender
  message_to_send    ; if comm_intention = "send", the bus will send this message to message_receivers
  message_receivers  ; List of all bus id to whom the message has to be sent 
   
  
  new_drive_intention; Used when the bus is replying to a message. This intention will be his new drive_intention if he "wins" the request.
  deviate_route      ; This is the route that the bus will follow when he is deviating from its main fixed_route
  new_fixed_route    ; This is the new fixed route that the bus will follow when we wins the request. He might first have to take the deviate route in order to reach this one.
  ] 

; added global variable : bus_number, bus_id_list, average distance travelled
; bus_deserving_stations: List of the number of bus deserving station i //This variable is global but is constructed thanks to local knowledge ! (Blackboard system)
globals [graph bus_number bus_id_list bus_deserving_stations]

to init-buses

  ; Initialize your agents here.
  
  if bus_id mod 6 = 0 [set fixed_route [3 9 8 6 8 2]]
  if bus_id mod 6 = 1 [set fixed_route [3 20 12 15 18]]
  if bus_id mod 6 = 2 [set fixed_route [3 20 21 22 0]]
  if bus_id mod 6 = 3 [set fixed_route [3 4 10 13 23 14]]
  if bus_id mod 6 = 4 [set fixed_route [3 4 5 17 7 1 19]]
  if bus_id mod 6 = 5 [set fixed_route [3 16 11]]
  
  
  if(bus_deserving_stations = 0 )
  [
    set bus_deserving_stations [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
  ]
  set bus_deserving_stations (update-bus-deserving-stations bus_deserving_stations [] fixed_route)
  
  set direction "GO"
  set route_index 1
  
  if bus_type = 1 [set bus_capacity 12]
  if bus_type = 2 [set bus_capacity 60]
  if bus_type = 3 [set bus_capacity 150]

  set desire "deserve" 
  set drive_intention "deserve" 
  set comm_intention "none"
  set addbus_intention "none"
  
  set message_receivers (list)
  ; This list contains the topology of the entire network of bus stops, which is known to all agents. You can use this, for instance, to calculate the shortest path between two bus stops.
  set graph [[22 15 14] [11 19 23 7] [8] [16 4 20 9] [3 5 10] [4 16 10 17] [8] [1 17 13] [2 6 9] [3 8 20] [4 5 17 13 21] [1 16 17] [20 15 22] [7 10 22 23] [0 23] [0 12 18] [3 5 11] [5 7 10 11] [15] [1 23] [3 9 12 21] [10 20 22] [0 12 13 21] [1 13 14 19]]
  
  ;TEST FUNCTIONS 
  ;show (split "[1 2 3]/test/5" "/")
  ;show (shortest-route2 0 5)
  ;let mess-id (build-m-id bus_id) 
  ;let mess (build-message bus_id mess-id "INFORM" "I am happy")
  ;show mess
  ;show (read-message mess)
  ;show bus_id_list
  ;show travelled_distance
  ;show find-way-to-route 3 [0 11]
  ;show best-route 0 [11 17 10 13]
  ;show best-route 0 [3 20 12 18] 
end

to drop-passenger[current_route]
  ; if the bus is in centraal, drop everyone that don't have this destination on this route
  ifelse current_stop = 3 
  [
      foreach bus_passengers 
      [ 
        let pass_stop (item 1 ?)  
        let should_drop? True
        ;check if passenger stop is on the bus route
        foreach current_route 
        [
          let route ?
          if (pass_stop = route )
          [ set should_drop? False ]
        ]
        ;check if the passenger stop is the current_stop 
        set should_drop? ((pass_stop = current_stop) or should_drop?)
        if (should_drop? = True)[drop-off-passenger (item 0 ?) ]
      ]
  ]
  [
    ; drop a passenger if it is his stop
      foreach bus_passengers [
        if item 1 ? = current_stop [drop-off-passenger (item 0 ?)] 
      ]
  ]
end
to pick-passenger[current_route]
    ; if the bus is in centraal pick passenger with destination that matches the bus route
    ifelse current_stop = 3 
    [
        foreach get-passengers-at-stop (current_stop) 
        [
          if length(bus_passengers) < bus_capacity 
          [
            let v ?
            foreach current_route 
            [
              if ((item 1 v = ?) and (? != current_stop) )[ pick-up-passenger (item 0 v) ]
            ]
          ]
        ]
    ]
    [
      
       ; L is a list of station before going to the same station
      let L []
      ;check direction
      if(direction = "GO")
      [
        ;get all stop after this one towards the end of the route
        let i route_index 
        while[i < length(current_route)]
        [
          set L lput (item i current_route) L
          set i (i + 1)
        ]
      ]
      if(direction = "RETURN")
      [
        ;get all stop after this one towards the end of the route
        let i route_index 
        while[i >= 0]
        [
          set L lput (item i current_route) L
          set i (i - 1)
        ]
      ]
      
      ; if the bus is not full 
      if length(bus_passengers) < bus_capacity 
      [ foreach get-passengers-at-stop (current_stop) 
        [  
          if length(bus_passengers) < bus_capacity 
          [
            ; if the passenger's destination is on this bus route and is on L, pick the passenger
            ifelse member? item 1 ? current_route 
            [
              if member? item 1 ? L 
              [
                pick-up-passenger (item 0 ?)
              ]
            ]
            ; if the passenger's destination is not on this bus route, but the bus goes to centraal, pick the passenger
            [
              if member? 3 L 
              [
                pick-up-passenger (item 0 ?)
              ]
            ]
          ]
        ]
      ]
    ]
      
end
to execute-actions 
  ; initialize bus_id_list
  if(bus_id_list) = 0 [set bus_id_list (list)]
 
  ;answer time is 1 ticks from this one , the whole conversation last 3 ticks (counting this one)
  ;filtered message
  let f_messages (retrieve-recent inbox ticks 4)
  ;Read all messages and apply the changes
  update-message-intentions f_messages
  
  update_desire
  update_addbus_intention
  update_drive_intention
  update_comm_intention f_messages
  

  ;send message 
  if(comm_intention = "send")
  [
    foreach message_receivers
    [my-send-message ? message_to_send]
  ]
  
  if(addbus_intention = "addinit")
  [
    ; initialize 6 bus with different routes at the beginning
    let i 0
      while [i < 6] [
        if bus_number != 0 [add-bus(3)]
        set bus_id_list lput (bus_number + 24) bus_id_list
        set bus_number bus_number + 1
        set i i + 1
      ]
  ]
  if(addbus_intention = "add")
  [
    ; add more bus as time increases
    add-bus(3)
    set bus_id_list lput (bus_number + 24) bus_id_list
    
    set bus_number bus_number + 1

  ]

  
  if(drive_intention = "deserve")
  [   
   ; check whether a bus is in a bus stop
   if current_stop = item route_index fixed_route [
    if(previous_stop != -1) [
      set travelled_distance travelled_distance + get-distance previous_stop current_stop
    ]
    ;compute next stop
    let break? false
    ;update index 
    if(direction = "GO" and (break? = false)) 
    [
      ;if we are at the last top in GO direction
      ifelse(route_index = (length(fixed_route)) - 1)
      [
        set direction "RETURN"
        set route_index (route_index - 1)
      ]
      [set route_index (route_index + 1)]
      set break? true
    ]
    
    if(direction = "RETURN" and (break? = false)) 
    [
      ;if  we are at the last top in RETURN direction
      ifelse(route_index = 0)
      [
        set direction "GO"
        set route_index (route_index + 1)
      ]
      [set route_index (route_index - 1)]
      set break? true
    ]
    
    drop-passenger fixed_route
    pick-passenger fixed_route
  ]
    travel-to item route_index fixed_route 
  ]
  if(drive_intention = "deviate")
  [
    ; check whether a bus is in a bus stop
   if current_stop = item route_index deviate_route 
   [
     if(previous_stop != -1) [
       set travelled_distance (travelled_distance + get-distance previous_stop current_stop)
     ]
       set route_index (route_index + 1)
       ;only drop passenger 
       drop-passenger deviate_route 
   ]
   if(route_index < length(deviate_route))
    [travel-to item route_index deviate_route]
  ]
end

; add each element of addList to the original
to-report update-bus-deserving-stations[original old_route new_route]
  let removed_station (list); keep track of station removed: in an old route [1 2 1 ] we only want to apply ONE -1 to item 0 of original
  let added_station (list); keep track of station added: in a route [1 2 1 ] we only want to apply ONE +1 to item 0 of original
  foreach old_route
  [
    if(not (member? ?  removed_station) ) 
    [
      set original (replace-item ?  original ( (item ? original) - 1))
      set removed_station lput ? removed_station
    ]
  ]
  foreach new_route
  [
    if(not (member? ?  added_station) ) 
    [
      set original (replace-item ?  original ( (item ? original) + 1))
      set added_station lput ? added_station
    ]

  ]
  report original
end

