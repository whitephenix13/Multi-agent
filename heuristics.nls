;the main heuristic that let a bus decide if he should do something or not 
;day_time given in ticks
to-report heuristic[my_bus_type route day_time]
  let H 0 
  
  let cost_per_patch 0
  if my_bus_type = 1 
  [set cost_per_patch 1]
   if my_bus_type = 2 
  [set cost_per_patch 1.5]
   if my_bus_type = 3 
  [set cost_per_patch 2]

  let mean_time 420
  let mean_travel_cost 175000 
  let time_importance 2
  let bus_speed 1
  let stop_per_person 4.25;mean number of stop per person 
  let distance_stops 6.32; mean distance between two stops
  
  let expected_people (compute-expected-people route day_time);
  
  let people_per_day 42776; the total number of people per day 
  let route_length (compute-route-length route)
  
  set H ( time_importance * mean_time * bus_speed / (stop_per_person * distance_stops)  * expected_people / people_per_day - mean_travel_cost * cost_per_patch * route_length)
  report H 

end

to-report check-overcrowded-station [bus_stop]
  ;TODO:
  let bus_deserve_ids item bus_stop bus_deserving_stations
  let total_remaining_seat 0
  let res 0
  foreach bus_deserve_ids [
    set total_remaining_seat (total_remaining_seat + remaining-bus-capacity bus_deserve_ids)
  ]
  ifelse(get-passengers-at-stop bus_stop > total_remaining_seat) [
    set res bus_stop
  ] 
  [
    set res false
  ]
  report res
end

to-report check-overcrowded-line [bus_route]
  ;TODO:
  ;for now, we determine n equals 2
  let n 3
  let res 0
  let counter 0
  foreach bus_route [
    let bus_deserve_ids item ? bus_deserving_stations
    let total_remaining_seat 0
    foreach bus_deserve_ids [
      set total_remaining_seat (total_remaining_seat + remaining-bus-capacity bus_deserve_ids)
    ]
    if(get-passengers-at-stop ? > total_remaining_seat) [
      set counter (counter + 1)
    ] 
  ]
  ifelse(counter > n) [
    set res bus_route
  ] 
  [
    set res false
  ]
  report res
end

to-report remaining-bus-capacity [b_id]
  let remaining_seat 0
  ask buses with [bus_id = b_id] [
    let total_passenger length(bus_passengers)
    let capacity bus_capacity
    set remaining_seat (bus_capacity - total_passenger)
  ]
  report remaining_seat
end

; calculate average travelled distance
to-report calculate-average-travelled-distance
  let average_distance 0
  foreach bus_id_list [
    ask buses with [bus_id = ?] [
      set average_distance average_distance + travelled_distance
    ]
  ]
  if(length(bus_id_list) != 0) [ set average_distance (average_distance / length(bus_id_list)) ]
  report average_distance
end

to-report compute-route-length [route]
  let leng 0 
  let prev_stop -1
  foreach route
  [
    ifelse( prev_stop = -1)
    [set prev_stop ?]
    [set leng (leng + (get-distance prev_stop ?) ) ]
  ]
  report leng
end

to-report parse-hourly-passenger-location[]
  file-open "hourly_passengers_location.csv"
  let hour 0
  let matrix (list) ; list of list of people, use hour then station id to access the element
  while [not file-at-end?]
  [
    let line file-read-line
    let people_at_station ( split line ";") ; for hour, the i'th item is the number of people at station i 
    let l_hour (list)
    foreach people_at_station
    [
      set l_hour lput (read-from-string ?) l_hour
    ]
    set matrix lput l_hour matrix
  ]
  file-close
  report matrix
end

to-report compute-expected-people[route day_time]
  ; Compute sum of people at stop / number of bus deserving this stop
  ;convert day_time that is in tick to hour time 
  let hour ((round (day_time / 60) ) mod 24)
  let a (1 - ((day_time / 60) mod 1)) ; get how much we take of hour
  let b (1 - a) ; get how much we take from (hour + 1)
  
  if (hourly_passenger_location = 0)
  [
    set hourly_passenger_location parse-hourly-passenger-location
  ]
  let _sum 0
  let encountered_stop (list) ; avoid to count twice a stop if it is twice in the route
  foreach route
  [
      if( not (member? ? encountered_stop) )
      [
        let num_pass_at_stop 0 ; = a * num_pass_at_stop_h1 + b * num_pass_at_stop_h2
        let num_pass_at_stop_h1 (item ? (item hour hourly_passenger_location))
        let num_pass_at_stop_h2 0
        ifelse(hour != 23)
        [
         set num_pass_at_stop_h2 (item ? (item (hour + 1) hourly_passenger_location))
        ]
        [
          set num_pass_at_stop_h2 0
        ]
        ;interpolate between current hour and next hour
        set num_pass_at_stop (a * num_pass_at_stop_h1 + b * num_pass_at_stop_h2)
        
        let num_bus_deserving_stop (length (item ? bus_deserving_stations) )
        set _sum (_sum + num_pass_at_stop / num_bus_deserving_stop)
        set encountered_stop lput ? encountered_stop
      ]
  ] 
  report _sum; 
end